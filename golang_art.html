<h1> Пишем RESTful API  на Golnag </h1>

Всем привет! Мы продолжаем серию статей, посвященных языку программировани Golang. В прошлый раз мы посмотрели как Golang чувствует себя в рамках функциональной парадигмы - и надо сказать, чувствовал он себя не слишком <a href="https://habr.com/ru/company/otus/blog/476346/"> уверенно </a> (большую часть возможностей пришлось эмулировать). Сегодня мы продолжим программировать на Go, только теперь попробуем его в том, в чем он по идее должен быть хорош - в создании REST API сервиса, в котором можно получать данные по запросу. В первой части я постараюсь объяснить более простую часть, в которой мы получаем данные из заранее созданного JSON struct, в которой мы положим типичный объект, например, статьи с заголовком, описанием и контентом. Во второй части статьи  мы все усложним: получим данные из базы данных  MySQL, трансформируем их в JSON и успешно отдадим по GET - запросу. Что ж, давайте приступим. Не хочу приводить определения REST в нашей статье, они и так просто везде, так что для быстрого введения можете прочитать <a href="https://ziginsider.github.io/rest-api/"> тут</a>.
Итак, поехали с импортов. Итого:
<source lang='golang'> 
package main

import (
	"encoding/json" // Для работы с json
	"fmt"           // библиотека для вывода данных в отладке
	"log"           // для логирования
	"net/http"      // и для обработки http запросов

	"github.com/gorilla/mux" //http роутер и диспатчер
)
   </source>
Итак, я думаю, что названия пакетов и комментарии говорят сами за себя. Кстати, будьте поаккуратнее с ctrl + s в VS Code - форматер go любит удалять пакеты при отсутствии их использования в коде.
Итого у нас нет классов у нас языке, но есть кое-что получше:
<source lang='golang'>
type Article struct {
	Title   string `json:"Title"`
	ID      int    `json: id` // если поставить просто id go что-то бурчит себе под нос
	Desc    string `json:"Desc"`
	Content string `json:"Content"`
}

type Articles []Article // здесь у нас создается массив наших статей. Для phpшников до боли знакомый прием
</source>	
Дальше мы создадим функцию, которая будет выдавать, например, домашнюю страницу по запросу. В дальнейшем, признаюсь, от нее особого толка не будет - но она будет прекрасной иллюстрацией простой функции, которая обрабатывает request - response.
<source lang='golang'>
	func homePage(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "<h1>Наш сервер начал работу </h1>") // я надеюсь флаги w и r уже знакомы нашему читателю 
}
</source>
Окей, здорово. Но нам нужна функция, которая будет вызывать эту функцию на запрос и запускать сервер. Кроме того, нам был не помешал еще пакет с функциями диспатчера, который сделает за нас всю грязную работу... Хорошо, что у нас уже есть пакет gorilla/mux:
<source lang='golang'>
func handleRequests() {
	myRouter := mux.NewRouter().StrictSlash(true) // ура роутинг 
	myRouter.HandleFunc("/", homePage) // ура роутер за нас все сделает и будут быстро и из коробки любые методы
	log.Fatal(http.ListenAndServe(":8801", myRouter)) // поднимаем это штуку
}
</source>
Что же нам осталось сделать, что бы минимальный костяк сервера у нас заработал? Правильно, в Go без функции main никуда:
 <source>
func main() {
	handleRequests()
}
 </source>
Если вас прям срочно нужно это поднять этот сверхмощный сервер и посмотреть, работает ли ваша штука, вводим в консоль:
 <source>
 	go run main.go
 </source>
 И через какое-то небольшое время компиляции эта штука заводится. Надеюсь подтверждающих скринов не надо.
 Окей, но пока очень скучно. Пришло время для функции, которая будет отдавать наши статейки в json:
<source>
func allArticles(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html; charset=utf-8") //без headers при попытке fetch браузер объяснит быстро, кто вы по жизни
	w.Header().Set("Access-Control-Allow-Origin", "*") // все разрешаем
	articles := Articles{
		Article{Title: "О дельфинах", ID: 1, Desc: "дельфинчики клевые", Content: "Дельфи́ны — водные млекопитающие отряда китообразных."},
		Article{Title: "О пингвинах", ID: 2, Desc: "Пингвины классные", Content: "Пингви́новые, или пингви́ны, — семейство нелетающих морских птиц, единственное современное в отряде пингвинообра́зных."},
	} // какая статья на хабре обходится без экскурса в живую природу. А если по делу, делаем новый объекты Article 

	fmt.Println("Endpoint Hit:All articles") // это так для отладки
	json.NewEncoder(w).Encode(articles) // отправляем наши статьи в JSON
}
</source>

Здорово, статьи с нами! Осталось их только отдать по запросу. Добавляем в наш handleRequests() новую строчку:
<source>
myRouter.HandleFunc("/articles", allArticles).Methods("GET") // и даже специализируем метод
</source>

Теперь, если мы перезапустим наш сервер, то мы сможем получать наши данные. Например, можно сделать запрос из нашего приложения, которое генерит страницу на JS, и получить данные:
<source lang="javascript">
async function f() {
    let response = await fetch('http://localhost:8801/articles');
    if (response.ok) {
        let json = await response.json();
        let value = JSON.parse(json);
        console.log(typeof(value));
        console.log(value.length);  //отладочные радости, что бы убедиться, что в каком виде пришло.
        for (let i = 1; i < value.length; i++) {
            draw(value[i]); // draw это функция которая отрисовывает наши статьи. Не думаю, что вы не сможете такое написать( и лучше конечно сразу на React)
        }
    } else {
        alert("Произошла ошибка HTTP: " + response.status);
    }

}
f(); // press F
</source>
 Конечно, нормальный человек скачал бы <a href= "https://www.getpostman.com/downloads/"> Postman </a> и посмотрел бы, как работает его запрос, немножко бы потестировал. Но это же скучно...
 Окей. Однако сейчас наше приложение поразительно уныло, и никакого толка от него нет - мы так все эти статьи могли в fixtures какие-нить записать с тем же успехом, и никакого сервера бы не понадобилось. Пора связать нашу красоту с базами данных. В качестве базы данных выступит MySQL. Мне показалось достаточно полезной данная <a href = 'https://www.vividcortex.com/resources/the-ultimate-guide-to-building-database-driven-apps-with-go'>книженция </a> , хотя лучше всего, мне кажется, сразу сверяться с документацией  <a href='https://golang.org/src/database/sql/example_test.go'> пакета </a> , который отвечает за коннект с базой данных. Итак, добавляем пакет и драйвер в наш импорт наверху:
<source lang="golang">
import (
	"database/sql"  // основной плагин для использования sql
	"encoding/json" // Для корректной работы с json
	"fmt"           // библиотека для вывода
	"log"           // для логирования
	"net/http"      // и для обработки http запросов

	_ "github.com/go-sql-driver/mysql" //драйвер для работы нашего sql
	"github.com/gorilla/mux"           //http роутер  и диспатчер
)
</source> 


Окей, и конечно же наша функция, которая отвечает за передачу всех статей, достаточно сильно изменится.
<source lang="golang">
func allArticles(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	sql := "SELECT * from articles" //сложнейший sql не поддающийся никакому анализу
	rows, err := getJSON(sql)
	log.Println(err)
	articles := rows
	fmt.Println("Endpoint Hit:All articles")
	json.NewEncoder(w).Encode(articles)
}
</source>

В предыдущем отрывке кода для получения json мы использовали магическую функцию getJSON. Вы точно хотите узнать, что у нее внутри? Если что, вы сами попросили, я тут ни причем:
<source lang="golang">

func getJSON(sqlString string) (string, error) {
	db, err := sql.Open("mysql", "pavel:@tcp(127.0.0.1:3306)/testdb")  //без пароля, имя пользователя - pavel, название базы данных - testdb
	if err != nil {
		panic(err.Error()) // panic относительно бесполезен. Для серьзной отладки вам нужен другой перехватчик ошибок
	}

	rows, err := db.Query(sqlString)  // осуществляем запрос, он приходит аргументом
	if err != nil {
		return "", err
	}
	columns, err := rows.Columns()
	if err != nil {
		return "", err
	}
	count := len(columns)
	tableData := make([]map[string]interface{}, 0)
	values := make([]interface{}, count)
	valuePtrs := make([]interface{}, count)
	for rows.Next() {
		for i := 0; i < count; i++ {
			valuePtrs[i] = &values[i]
		}
		rows.Scan(valuePtrs...)
		entry := make(map[string]interface{}) 
		for i, col := range columns {
			var v interface{}
			val := values[i]
			b, ok := val.([]byte)
			if ok {
				v = string(b)
			} else {
				v = val
			}
			entry[col] = v
		}
		tableData = append(tableData, entry) // там много всяких интерфейсов, поэтому просто скажу, что мы делаем таблицу, в которую потом переведем в JSON
	}
	jsonData, err := json.Marshal(tableData)
	if err != nil {
		return "", err
	}
	return string(jsonData), nil
}
</source>

Все кул, теперь осталось только специализировать наш запрос в handleRequest():
<source lang="golang"> 
myRouter.HandleFunc("/articles", allArticles).Methods("GET")
</source>

Отлично! Теперь просто запустите, например, свой MySQLWorkBranch(да да, я пользуюсь интерфейсами) и создайте там схему testdb, где можете создать таблицу articles со стоблцами id, Title, Desc, Content - и после наполнения их каким-то контентом( ну это элементарщину давайте вы сами найдете) вы сможете увидеть, как ваша система заработает. Я сознательно немного упростил запрос, что бы материал стал проще. Но теперь вы можете поменять таблицу данных на более реальную, и по посмотреть как работает ваш REST API c другими запросами. Как напишите и скомпилировать с помощью go build и задеплоить - все например, хвалят <a href="https://cloud.google.com/appengine/docs/standard/go/building-app/"> google	cloud </a> ( это не реклама) за весьма небольшую плату(есть и бесплатная квота).
На этом все. Надеюсь, несмотря на пугающую часть обработки базы данных со множеством интерфейсов, я надеюсь, что язык немного приподнялся в ваших глазах. И несмотря на некую лексическую бедность, ждем GO 2, и надеемся, что мы в итоге получим компилируемый, быстрый и удобный, лексически богатый язык программирвания со множеством сфер применения. 

























